#!/usr/bin/env python3
# -*- coding: utf-8 -*-


import heapq
from collections import defaultdict


class GraphProblem:
    """
    Задача поиска кратчайшего пути в графе с учётом весов рёбер.
    """
    def __init__(self, graph_structure, start_node, goal_node):
        self.graph_structure = graph_structure  # Словарь смежности, включая веса рёбер
        self.start_node = start_node  # Начальный узел
        self.goal_node = goal_node  # Целевой узел

    def actions(self, current_node):
        return self.graph_structure[current_node]  # Возвращает список смежных узлов с весами

    def is_goal(self, current_node):
        return current_node == self.goal_node


class Node:
    """
    Узел в дереве поиска.
    """
    def __init__(self, state_name, parent_node=None, total_cost=0):
        self.state_name = state_name
        self.parent_node = parent_node
        self.total_cost = total_cost

    def path(self):
        """
        Восстановление пути от начального состояния до текущего узла.
        """
        current_node, path_nodes = self, []
        while current_node:
            path_nodes.append(current_node.state_name)
            current_node = current_node.parent_node
        return list(reversed(path_nodes))


def bfs_search(problem_instance):
    """
    Поиск кратчайшего пути, реализованный как поиск в ширину с учетом весов ребер графа.
    """
    # Очередь с приоритетом, где каждый элемент - кортеж (стоимость, идентификатор, узел)
    priority_queue = []
    counter = 0  # Уникальный идентификатор для узлов
    heapq.heappush(priority_queue, (0, counter, Node(problem_instance.start_node)))

    # Словарь для отслеживания минимальной стоимости до каждого узла
    visited_costs = {}

    while priority_queue:
        # Извлекаем узел с наименьшей стоимостью
        current_cost, _, current_node = heapq.heappop(priority_queue)

        # Если этот узел уже был обработан с меньшей или равной стоимостью - пропускаем
        if current_node.state_name in visited_costs and visited_costs[current_node.state_name] <= current_cost:
            continue

        # Обновляем минимальную стоимость до текущего узла
        visited_costs[current_node.state_name] = current_cost

        # Проверяем, достигли ли цели
        if problem_instance.is_goal(current_node.state_name):
            return current_node.path(), current_cost

        # Обрабатываем соседей
        for neighbor_name, edge_cost in problem_instance.actions(current_node.state_name):
            new_path_cost = current_cost + edge_cost
            # Добавляем в очередь, если новый путь короче
            if neighbor_name not in visited_costs or visited_costs[neighbor_name] > new_path_cost:
                counter += 1  # Увеличиваем идентификатор
                heapq.heappush(priority_queue,
                               (new_path_cost, counter, Node(neighbor_name, current_node, new_path_cost)))

    return None, float('inf')  # Если путь не найден


if __name__ == "__main__":
    # Список рёбер графа
    graph_edges = [
        # Город Буриндал
        ("Буриндал", "Уоррен", 271),
        ("Буриндал", "Нинган", 156),
        ("Буриндал", "Кобар", 204),

        # Город Кобар
        ("Кобар", "Канбелего", 50),
        ("Кобар", "Наймаджи", 97.5),
        ("Кобар", "Гулгуния", 110),

        # Город Гулгуния
        ("Гулгуния", "Наймаджи", 46),
        ("Гулгуния", "Матакана", 70),

        # Город Наймаджи
        ("Наймаджи", "Канбелего", 61),
        ("Наймаджи", "Нинган", 122),
        ("Наймаджи", "Бобада", 150),

        # Город Нинган
        ("Нинган", "Канбелего", 86),
        ("Нинган", "Уоррен", 78),
        ("Нинган", "Бобада", 150),

        # Город Уоррен
        ("Уоррен", "Гилгандра", 103),
        ("Уоррен", "Нарромин", 86),

        # Город Нарромин
        ("Нарромин", "Бобада", 203),
        ("Нарромин", "Пикхилл", 57),
        ("Нарромин", "Даббо", 41),

        # Город Пикхилл
        ("Пикхилл", "Даббо", 70),
        ("Пикхилл", "Веллингтон", 109),
        ("Пикхилл", "Медроз", 172),
        ("Пикхилл", "Кондоболин", 147),
        ("Пикхилл", "Паркс", 55),

        # Город Даббо
        ("Даббо", "Гилгандра", 66),
        ("Даббо", "Данду", 88),
        ("Даббо", "Веллингтон", 49),

        # Город Бобада
        ("Бобада", "Медроз", 50),

        # Город Медроз
        ("Медроз", "Кондоболин", 56),

        # Город Кондоболин
        ("Кондоболин", "Паркс", 104),
        ("Кондоболин", "Гренфелл", 164),
        ("Кондоболин", "Уэст_Уайалонг", 104),
        ("Кондоболин", "Лейк_Каргеллиго", 94),

        # Город Матакана
        ("Матакана", "Лейк_Каргеллиго", 99),

        # Город Лейк_Каргеллиго
        ("Лейк_Каргеллиго", "Уэст_Уайалонг", 119),

        # Город Уэст_Уайалонг
        ("Уэст_Уайалонг", "Гренфелл", 113),
        ("Уэст_Уайалонг", "Янг", 150),

        # Город Гренфелл
        ("Гренфелл", "Паркс", 100),
        ("Гренфелл", "Ориндж", 139),
        ("Гренфелл", "Кора", 58),
        ("Гренфелл", "Янг", 53),

        # Город Ориндж
        ("Ориндж", "Кора", 104),
        ("Ориндж", "Паркс", 104),
        ("Ориндж", "Веллингтон", 105),
        ("Ориндж", "Батерст", 55),

        # Город Веллингтон
        ("Веллингтон", "Маджи", 114),

        # Город Маджи
        ("Маджи", "Данду", 80),
        ("Маджи", "Меррива", 167),
        ("Маджи", "Сеснок", 255),
        ("Маджи", "Батерст", 134),
        ("Маджи", "Литго", 126),

        # Город Батерст
        ("Батерст", "Литго", 62),
        ("Батерст", "Кора", 106),
        ("Батерст", "Круквелл", 155),

        # Город Бурова
        ("Бурова", "Янг", 47),
        ("Бурова", "Кора", 78),
        ("Бурова", "Круквелл", 85),
        ("Бурова", "Гоулберн", 140),

        # Город Круквелл
        ("Круквелл", "Кетумба", 229),
        ("Круквелл", "Гоулберн", 43),

        # Город Гоулберн
        ("Гоулберн", "Нора", 125),
        ("Гоулберн", "Боурал", 83),

        # Город Боурал
        ("Боурал", "Нора", 66),
        ("Боурал", "Киама", 77),
        ("Боурал", "Вуллонгонг", 82),
        ("Боурал", "Камден", 68),

        # Город Киама
        ("Киама", "Нора", 55),
        ("Киама", "Вуллонгонг", 43),

        # Город Вуллонгонг
        ("Вуллонгонг", "Камден", 72),
        ("Вуллонгонг", "Сидней", 80),

        # Город Камден
        ("Камден", "Кетумба", 96),
        ("Камден", "Сидней", 75),

        # Город Сидней
        ("Сидней", "Кетумба", 106),
        ("Сидней", "Вои_вои", 81),

        # Город Вои_вои
        ("Вои_вои", "Кетумба", 156),
        ("Вои_вои", "Госфорд", 16),

        # Город Госфорд
        ("Госфорд", "Ньюкасл", 84),
        ("Госфорд", "Сеснок", 85),
        ("Госфорд", "Литго", 174),

        # Город Сеснок
        ("Сеснок", "Меррива", 159),
        ("Сеснок", "Синглтон", 53),
        ("Сеснок", "Ньюкасл", 45),

        # Город Ньюкасл
        ("Ньюкасл", "Мейтленд", 34),
        ("Ньюкасл", "Дангог", 104),

        # Город Мейтленд
        ("Мейтленд", "Дангог", 53),
        ("Мейтленд", "Синглтон", 48),

        # Город Синглтон
        ("Синглтон", "Маселбрук", 49),

        # Город Меррива
        ("Меррива", "Маселбрук", 77),
        ("Меррива", "Кула", 81),

        # Город Кула
        ("Кула", "Данду", 47),
        ("Кула", "Тураина", 132),

        # Город Гилгандра
        ("Гилгандра", "Тураина", 49),
        ("Гилгандра", "Данду", 92),

        # Город Кетумба
        ("Кетумба", "Литго", 41)
    ]

    # Преобразование в словарь смежности для неориентированного графа
    adjacency_list = defaultdict(list)
    for start, end, edge_costs in graph_edges:
        adjacency_list[start].append((end, edge_costs))
        adjacency_list[end].append((start, edge_costs))

    # Определение задачи
    search_task = GraphProblem(adjacency_list, "Буриндал", "Сидней")

    # Поиск кратчайшего пути
    shortest_path, total_cost_way = bfs_search(search_task)

    # Вывод результата
    if shortest_path:
        print("Кратчайший путь:", " -> ".join(shortest_path))
        print("Общая стоимость:", total_cost_way)
    else:
        print("Путь не найден.")
