#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import heapq
import math
from abc import ABC, abstractmethod
from collections import deque


class Problem(ABC):
    """
    Абстрактный класс для формальной постановки задачи.
    Новый домен (конкретная задача) должен специализировать этот класс,
    переопределяя методы actions и result, а при необходимости action_cost, h и is_goal.
    """

    def __init__(self, initial=None, goal=None, **kwargs):
        self.initial = initial
        self.goal = goal
        # Сохраняем все остальные переданные параметры (при желании).
        for k, v in kwargs.items():
            setattr(self, k, v)

    @abstractmethod
    def actions(self, state):
        """Вернуть доступные действия (операторы) из данного состояния."""
        pass

    @abstractmethod
    def result(self, state, action):
        """Вернуть результат применения действия к состоянию."""
        pass

    def is_goal(self, state):
        """Проверка, является ли состояние целевым."""
        return state == self.goal

    def action_cost(self, s, a, s1):
        """
        Возвращает стоимость применения действия a,
        переводящего состояние s в состояние s1.
        По умолчанию = 1.
        """

        return 1

    def h(self, node):
        """Эвристическая функция; по умолчанию = 0."""
        return 0

    def __str__(self):
        return f"{type(self).__name__}({self.initial!r}, {self.goal!r})"


class Node:
    """Узел в дереве поиска."""

    def __init__(self, state, parent=None, action=None, path_cost=0.0):
        self.state = state  # Текущее состояние
        self.parent = parent  # Родительский узел
        self.action = action  # Действие, которое привело к этому узлу
        self.path_cost = path_cost  # Стоимость пути от начального узла

    def __repr__(self):
        return f"<Node {self.state}>"

    # Позволяет сравнивать узлы по стоимости пути (для приоритетных очередей)
    def __lt__(self, other):
        return self.path_cost < other.path_cost

    # Глубина узла — длина пути от корня (получаем рекурсивно)
    def __len__(self):
        if self.parent is None:
            return 0
        else:
            return 1 + len(self.parent)


# Специальные «сигнальные» узлы
failure = Node("failure", path_cost=math.inf)
cutoff = Node("cutoff", path_cost=math.inf)


def expand(problem, node):
    """Раскрываем (расширяем) узел, генерируя все дочерние узлы."""
    s = node.state
    for action in problem.actions(s):
        s1 = problem.result(s, action)
        cost = node.path_cost + problem.action_cost(s, action, s1)
        yield Node(state=s1, parent=node, action=action, path_cost=cost)


def path_actions(node):
    """Последовательность действий, чтобы добраться от корня до данного узла."""
    if node.parent is None:
        return []
    return path_actions(node.parent) + [node.action]


def path_states(node):
    """Последовательность состояний от корня до данного узла."""
    if node.parent is None:
        return [node.state]
    return path_states(node.parent) + [node.state]


FIFOQueue = deque  # Для поиска в ширину (очередь FIFO)


class PriorityQueue:
    """Очередь с приоритетом, где элемент с минимальным значением key(item) извлекается первым."""

    def __init__(self, items=(), key=lambda x: x):
        self.key = key
        self.items = []  # внутри храним (priority, item)
        for item in items:
            self.add(item)

    def add(self, item):
        heapq.heappush(self.items, (self.key(item), item))

    def pop(self):
        return heapq.heappop(self.items)[1]

    def top(self):
        return self.items[0][1]

    def __len__(self):
        return len(self.items)


class MapProblem(Problem):
    """
    Описание конкретной задачи.
    """

    def __init__(self, initial, goal, graph):
        """
        Конструктор класса MapProblem, описывающего конкретную задачу.

        :param initial: Начальный город;
        :param goal: Конечный город.
        :param graph: Граф городов.
        """

        super().__init__(initial=initial, goal=goal)
        self.graph = graph  # словарь словарей для весов рёбер

    def actions(self, state):
        """Возвращаем всех соседей из данного города."""
        return list(self.graph[state].keys())

    def result(self, state, action):
        """Результат перехода: если из 'state' пойти в 'action', то окажемся в 'action'."""
        return action

    def action_cost(self, s, a, s1):
        """Стоимость рёбра s->s1 (здесь a == s1)."""
        return self.graph[s][s1]


def breadth_first_search(problem):
    """
    Поиск в ширину с учётом весов рёбер.
    Возвращает узел с целевым состоянием или failure, если решения нет.
    Порядок выбора узла из frontier определяется его path_cost (минимальная сумма весов).
    """

    # Создаём начальный узел
    start_node = Node(problem.initial, path_cost=0)
    # Помещаем его в приоритетную очередь (ключ = path_cost)
    frontier = PriorityQueue(key=lambda node: node.path_cost)
    frontier.add(start_node)

    # Пока есть узлы для расширения
    while len(frontier) > 0:
        # Извлекаем узел с наименьшим path_cost
        node = frontier.pop()

        # Проверяем, не достигли ли мы цели
        if problem.is_goal(node.state):
            return node

        # Расширяем узел и добавляем дочерние узлы в очередь
        for child in expand(problem, node):
            frontier.add(child)

    # Если очередь опустела, а цель не достигнута
    return failure


def main():
    """
    Главная функция программы.
    """

    graph = {
        "Буриндал": {"Уоррен": 271, "Нинган": 156, "Кобар": 204},
        "Уоррен": {"Буриндал": 271, "Нинган": 78, "Гилгандра": 103, "Нарромин": 86},
        "Нинган": {"Буриндал": 156, "Канбелего": 86, "Уоррен": 78, "Бобада": 150, "Наймаджи": 122},
        "Кобар": {"Буриндал": 204, "Канбелего": 50, "Наймаджи": 97.5, "Гулгуния": 110},
        "Канбелего": {"Кобар": 50, "Наймаджи": 61, "Нинган": 86},
        "Наймаджи": {"Канбелего": 61, "Нинган": 122, "Бобада": 150, "Кобар": 97.5, "Гулгуния": 46},
        "Гулгуния": {"Кобар": 110, "Наймаджи": 46, "Матакана": 70},
        "Матакана": {"Гулгуния": 70, "Лейк_Каргеллиго": 99},
        "Бобада": {"Наймаджи": 150, "Нинган": 150, "Нарромин": 203, "Медроз": 50},
        "Нарромин": {"Уоррен": 86, "Бобада": 203, "Пикхилл": 57, "Даббо": 41},
        "Пикхилл": {"Нарромин": 57, "Даббо": 70, "Веллингтон": 109, "Медроз": 172, "Кондоболин": 147, "Паркс": 55},
        "Даббо": {"Нарромин": 41, "Гилгандра": 66, "Данду": 88, "Веллингтон": 49, "Пикхилл": 70},
        "Гилгандра": {"Уоррен": 103, "Даббо": 66, "Тураина": 49, "Данду": 92},
        "Данду": {"Даббо": 88, "Маджи": 80, "Гилгандра": 92, "Кула": 47},
        "Медроз": {"Бобада": 50, "Кондоболин": 56, "Пикхилл": 172},
        "Кондоболин": {
            "Медроз": 56,
            "Паркс": 104,
            "Гренфелл": 164,
            "Уэст_Уайалонг": 104,
            "Лейк_Каргеллиго": 94,
            "Пикхилл": 147,
        },
        "Паркс": {"Пикхилл": 55, "Кондоболин": 104, "Гренфелл": 100, "Ориндж": 104},
        "Гренфелл": {"Паркс": 100, "Ориндж": 139, "Кора": 58, "Янг": 53, "Кондоболин": 164, "Уэст_Уайалонг": 113},
        "Ориндж": {"Кора": 104, "Паркс": 104, "Веллингтон": 105, "Батерст": 55, "Гренфелл": 139},
        "Веллингтон": {"Маджи": 114, "Пикхилл": 109, "Даббо": 49, "Ориндж": 105},
        "Маджи": {"Веллингтон": 114, "Данду": 80, "Меррива": 167, "Сеснок": 255, "Батерст": 134, "Литго": 126},
        "Батерст": {"Литго": 62, "Кора": 106, "Круквелл": 155, "Ориндж": 55, "Маджи": 134},
        "Литго": {"Батерст": 62, "Кетумба": 41, "Маджи": 126, "Госфорд": 174},
        "Кора": {"Гренфелл": 58, "Ориндж": 104, "Батерст": 106, "Бурова": 78},
        "Бурова": {"Янг": 47, "Кора": 78, "Круквелл": 85, "Гоулберн": 140},
        "Круквелл": {"Батерст": 155, "Кетумба": 229, "Гоулберн": 43, "Бурова": 85},
        "Гоулберн": {"Бурова": 140, "Круквелл": 43, "Нора": 125, "Боурал": 83},
        "Нора": {"Гоулберн": 125, "Боурал": 66, "Киама": 55},
        "Боурал": {"Нора": 66, "Киама": 77, "Вуллонгонг": 82, "Камден": 68, "Гоулберн": 83},
        "Киама": {"Нора": 55, "Вуллонгонг": 43, "Боурал": 77},
        "Вуллонгонг": {"Киама": 43, "Боурал": 82, "Камден": 72, "Сидней": 80},
        "Камден": {"Боурал": 68, "Вуллонгонг": 72, "Кетумба": 96, "Сидней": 75},
        "Сидней": {"Вуллонгонг": 80, "Камден": 75, "Кетумба": 106, "Вои_вои": 81},
        "Кетумба": {"Литго": 41, "Сидней": 106, "Камден": 96, "Вои_вои": 156, "Круквелл": 229},
        "Вои_вои": {"Сидней": 81, "Кетумба": 156, "Госфорд": 16},
        "Госфорд": {"Вои_вои": 16, "Ньюкасл": 84, "Сеснок": 85, "Литго": 174},
        "Ньюкасл": {"Госфорд": 84, "Сеснок": 45, "Мейтленд": 34, "Дангог": 104},
        "Сеснок": {"Госфорд": 85, "Ньюкасл": 45, "Меррива": 159, "Синглтон": 53, "Маджи": 255},
        "Мейтленд": {"Ньюкасл": 34, "Дангог": 53, "Синглтон": 48},
        "Дангог": {"Ньюкасл": 104, "Мейтленд": 53},
        "Синглтон": {"Сеснок": 53, "Мейтленд": 48, "Маселбрук": 49},
        "Маселбрук": {"Синглтон": 49, "Меррива": 77},
        "Меррива": {"Сеснок": 159, "Маселбрук": 77, "Кула": 81, "Маджи": 167},
        "Кула": {"Меррива": 81, "Данду": 47, "Тураина": 132},
        "Тураина": {"Кула": 132, "Гилгандра": 49},
        "Лейк_Каргеллиго": {"Матакана": 99, "Кондоболин": 94, "Уэст_Уайалонг": 119},
        "Уэст_Уайалонг": {"Лейк_Каргеллиго": 119, "Кондоболин": 104, "Гренфелл": 113, "Янг": 150},
        "Янг": {"Уэст_Уайалонг": 150, "Гренфелл": 53, "Бурова": 47},
    }

    # Найдем кратчайший путь из города Буриндал в город Сидней:
    problem = MapProblem(initial="Буриндал", goal="Сидней", graph=graph)

    solution_node = breadth_first_search(problem)
    if solution_node is failure:
        print("Путь не найден!")
    else:
        # Восстанавливаем маршрут
        route = path_states(solution_node)
        print("Маршрут:", " -> ".join(route))
        print("Суммарная стоимость:", solution_node.path_cost)


if __name__ == "__main__":
    main()
